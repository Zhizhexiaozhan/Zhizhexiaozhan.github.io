<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>音乐节奏弹幕粒子效果</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <!-- 画布用于显示粒子效果 -->
    <canvas id="particleCanvas"></canvas>

    <!-- 背景音乐 -->
    <audio id="backgroundMusic" loop>
        <source src="background_music.mp3" type="audio/mpeg">
        您的浏览器不支持音频播放。
    </audio>

    <script>
        // 获取画布和上下文
        const canvas = document.getElementById('particleCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // 定义文字内容
        const textList = [
            '直播', '运营', '培训', '公会', '美颜',
            '娱乐', '抖音', '快手', '服道化', '小红书'
        ];
        let currentTextIndex = 0; // 当前文字的索引

        // 粒子类
        class Particle {
            constructor(x, y, targetX, targetY) {
                this.x = x;
                this.y = y;
                this.targetX = targetX; // 目标位置
                this.targetY = targetY;
                this.size = Math.random() * 10 + 5; // 初始大小
                this.color = `hsl(${Math.random() * 360}, 50%, 50%)`; // 随机颜色
                this.speed = Math.random() * 2 + 1; // 移动速度
                this.angle = Math.random() * Math.PI * 2; // 随机角度
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.closePath();
                ctx.fill();
            }

            update(frequencyData) {
                // 向目标位置移动
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                this.x += dx * 0.05;
                this.y += dy * 0.05;

                // 根据音频频率调整粒子大小
                if (frequencyData) {
                    const frequencyIndex = Math.floor((this.x / canvas.width) * frequencyData.length);
                    const frequencyValue = frequencyData[frequencyIndex] / 255; // 归一化到 0-1
                    this.size = 5 + frequencyValue * 20; // 粒子大小随频率变化
                }

                // 如果粒子移动到屏幕外，重置位置
                if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
                    this.x = Math.random() * canvas.width;
                    this.y = Math.random() * canvas.height;
                }
            }
        }

        // 生成粒子
        let particles = [];
        function generateParticlesFromText(text) {
            const fontFamily = 'Arial';
            const fontSize = 100; // 文字大小

            // 创建离屏Canvas
            const offCanvas = document.createElement('canvas');
            const offCtx = offCanvas.getContext('2d');
            offCanvas.width = canvas.width;
            offCanvas.height = canvas.height;
            offCtx.font = `${fontSize}px ${fontFamily}`;
            offCtx.textAlign = 'center';
            offCtx.textBaseline = 'middle';
            offCtx.fillStyle = '#fff';

            // 绘制文字
            offCtx.fillText(text, canvas.width / 2, canvas.height / 2);

            // 获取像素数据
            const imageData = offCtx.getImageData(0, 0, canvas.width, canvas.height).data;

            // 生成新粒子
            const newParticles = [];
            for (let y = 0; y < canvas.height; y += 10) {
                for (let x = 0; x < canvas.width; x += 10) {
                    const pixelIndex = (y * canvas.width + x) * 4;
                    if (imageData[pixelIndex] > 128) { // 如果像素是白色
                        const targetX = x;
                        const targetY = y;
                        const particleX = Math.random() * canvas.width;
                        const particleY = Math.random() * canvas.height;
                        newParticles.push(new Particle(particleX, particleY, targetX, targetY));
                    }
                }
            }

            return newParticles;
        }

        // 初始化粒子
        particles = generateParticlesFromText(textList[currentTextIndex]);

        // 音频分析
        let audioContext, analyser, frequencyData;
        const backgroundMusic = document.getElementById('backgroundMusic');

        // 初始化音频分析
        function initAudioAnalyser() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 256; // 设置 FFT 大小
            const source = audioContext.createMediaElementSource(backgroundMusic);
            source.connect(analyser);
            analyser.connect(audioContext.destination);
            frequencyData = new Uint8Array(analyser.frequencyBinCount);
        }

        // 播放背景音乐并初始化音频分析
        function playBackgroundMusic() {
            backgroundMusic.play()
                .then(() => {
                    console.log('背景音乐开始播放');
                    initAudioAnalyser();
                })
                .catch(error => {
                    console.log('背景音乐播放失败，用户可能未与页面交互。');
                    alert('请点击页面以播放背景音乐');
                });
        }

        // 监听用户点击事件以播放音乐
        document.addEventListener('click', () => {
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume(); // 恢复音频上下文
            }
            playBackgroundMusic();
        }, { once: true }); // 只监听一次点击事件

        // 文字切换逻辑
        let lastTextChangeTime = 0;
        const textChangeInterval = 2000; // 每2秒切换一次文字

        function updateText() {
            const currentTime = Date.now();
            if (currentTime - lastTextChangeTime > textChangeInterval) {
                lastTextChangeTime = currentTime;
                currentTextIndex = (currentTextIndex + 1) % textList.length; // 切换到下一个文字
                particles = generateParticlesFromText(textList[currentTextIndex]); // 重新生成粒子
            }
        }

        // 动画循环
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 获取音频频率数据
            if (analyser) {
                analyser.getByteFrequencyData(frequencyData);
            }

            // 更新并绘制粒子
            particles.forEach(particle => {
                particle.draw();
                particle.update(frequencyData);
            });

            // 更新文字
            updateText();

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
